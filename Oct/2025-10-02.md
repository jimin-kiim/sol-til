## 날짜: 2025-10-02

### 스크럼
- 학습 목표 1 : User 리소스, Post 리소스 관련 레이어드 아키텍처 기반 CRUD REST API 구현 완수
- 학습 목표 2 : JPA, Spring JPA, JPQL, QueryDSL 개요 이해

### 새로 배운 내용
#### User 리소스, Post 리소스 관련 레이어드 아키텍처 기반 CRUD REST API 구현 완수
- RequestDTO, ResponseDTO를 만들고 매퍼 클래스로 엔터티와 상호 변환되도록 구현했다. 
- Spring Security를 세팅해 BCryptPasswordEncoder를 사용해 비밀번호를 암호화해 저장했다. 
- DTO에 Validation을 적용했다. @NotBlank는 String 타입 필드에만 적용할 수 있고 LocalDateTime, Long, Integer.. 등의 다른 타입의 경우 @NotNull을 사용한다. 
- Repository에서는 Spring Data JPA를 활용했다. 

#### JPA, Spring JPA, JPQL, QueryDSL 개요 이해
- 데이터베이스는 데이터의 저장, 관리라는 필요에 의해 등장했고 관계형 데이터베이스는 데이터의 중복을 줄이고 관계를 중심으로 구조화하기 위해 등장했다. 
- 복잡한 RDB 질의를 하고 체계적인 질의를 가능하게 한 것이 SQL이고 자바에서의 RDB SQL 실행은 JDBC를 통해 이뤄진다.
- 객체와 테이블의 차이를 해소하고 반복되는 SQL을 정리하는 것이 ORM이고 JPA(Java Persistence API)는 자바 표준 ORM 인터페이스이다. 
- JPQL은 엔터티 객체를 중심으로 하는 쿼리 언어이고 DB 레벨에서 데이터를 처리해 성능에 유리하다.
- Spring Data JPA는 자주 쓰이는 대부분의 JPA 동작들을 미리 구현해 둔 것으로, 내부적으로 순수 JPA를 쓰며 기본 CRUD를 자동 제공하고 메서드 이름만으로도 쿼리 생성이 가능하다.
- QueryDSL은 JPQL이나 SQL을 직접 작성하지 않고 메소드 호출과 객체지향 문법을 이용해 쿼리를 표현할 수 있게 해주는 쿼리 라이브러리이다. 

### 오늘의 도전 과제와 해결 방법
- 406 에러를 만나 JSON 직렬화와 역직렬화, Jackson에 대해서 알아봤다. 직렬화란 객체를 JSON으로 변환하는 작업을 말하는데 자바에서 이를 가능케 하는 라이브러리가 Jackson이다. Jackson은 필드를 찾을 때 getter, setter에서 앞의 get, set을 떼고 대문자를 소문자로 바꿔 필드를 찾기에 getter가 있어야 한다. ResponseDTO에 getter 어노테이션을 붙여주니 에러가 해결됐다. 
- write operation을 할 땐 @Transactional 어노테이션을 붙여 줘야 한다. 그렇지 않으면 DB에 반영이 안 되는데, 이유에 대해서는 따로 공부를 해 정리해 봐야 할 것 같다. 

### 오늘의 회고
- 많이 한 것 같은데, 하루 동안 투자한 시간도 많은데 정리를 하고 나니 생각보다 적은 일을 한 것 같아 당황스럽다.
- 할 일은 많고 시간은 빨리 간다. 내일도 부지런히 살 계획이다. 

### 참고 자료 및 링크
- [JSON 직렬화와 역직렬화](https://rlaehddnd0422.tistory.com/218)
- [406 에러와 Getter](https://stackoverflow.com/questions/28466207/could-not-find-acceptable-representation-using-spring-boot-starter-web)
- [406에러와 직렬화, Jackson과 Getter](https://hoonsb.tistory.com/85)
